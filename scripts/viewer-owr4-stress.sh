#!/usr/bin/env bash
set -euo pipefail

repo_root=$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)
cd "$repo_root"

usage() {
  cat <<'USAGE'
Usage: ./scripts/viewer-owr4-stress.sh [options]

Options:
  --duration-secs <n>        duration per scenario in seconds (default: 45)
  --tick-ms <n>              world_viewer_live tick interval (default: 120)
  --base-port <n>            first port for scenario runs (default: 5420)
  --out-dir <path>           output root directory (default: .tmp/viewer_owr4_stress)
  --event-window-size <n>    viewer event window cap for stress capture (default: 50000)
  --scenarios <csv>          scenario list, comma separated (default: triad_region_bootstrap,llm_bootstrap)
  --profile <name>           performance profile: web_desktop|high_density|stress (default: web_desktop)
  --fps-target <n>           override target FPS for profile scoring (default by profile)
  --fps-min <n>              override minimum acceptable FPS gate (default by profile)
  --perf-budget-ms <n>       frame budget used by perf_probe over_budget_pct (default: 1000/fps_min)
  --max-over-budget-pct <n>  max allowed over_budget_pct before fail (default: 10)
  --baseline-csv <path>      optional baseline CSV generated by this script
  --max-regression-pct <n>   max allowed regression vs baseline (%) (default: 10)
  --enforce-gate             exit non-zero when overall_status=fail
  --no-prewarm               skip cargo build prewarm
  -h, --help                 show help

Behavior:
  - Scenario "llm_bootstrap" will be launched with --llm when OPENAI_API_KEY is present.
  - Without OPENAI_API_KEY, "llm_bootstrap" falls back to script mode and is marked as script_fallback.
  - viewer runs in headless-online mode and emits perf_probe/event counters to logs.
  - output includes per-scenario logs + CSV + Markdown + JSON summary.
USAGE
}

run() {
  echo "+ $*"
  "$@"
}

float_lt() {
  awk -v left="$1" -v right="$2" 'BEGIN { exit !(left < right) }'
}

float_gt() {
  awk -v left="$1" -v right="$2" 'BEGIN { exit !(left > right) }'
}

join_notes() {
  if [[ $# -eq 0 ]]; then
    echo "ok"
    return
  fi
  local IFS=';'
  echo "$*"
}

parse_perf_metrics() {
  local log_file="$1"
  awk '
    /viewer perf_probe/ {
      line_avg = ""
      line_p95 = ""
      line_over = ""
      line_auto = ""
      line_hotspot = ""
      line_runtime_health = ""
      line_runtime_bottleneck = ""
      line_runtime_tick = ""
      line_runtime_decision = ""
      line_runtime_action = ""
      line_runtime_callback = ""
      line_runtime_llm_api = ""
      line_label_capacity = ""
      line_overlay_capacity = ""
      line_event_backlog = ""
      for (i = 1; i <= NF; i++) {
        if ($i ~ /^avg=/) {
          split($i, parts, "=")
          line_avg = parts[2] + 0
        } else if ($i ~ /^p95=/) {
          split($i, parts, "=")
          line_p95 = parts[2] + 0
        } else if ($i ~ /^over_budget_pct=/) {
          split($i, parts, "=")
          line_over = parts[2] + 0
        } else if ($i ~ /^auto_degrade=/) {
          split($i, parts, "=")
          line_auto = parts[2]
        } else if ($i ~ /^hotspot=/) {
          split($i, parts, "=")
          line_hotspot = parts[2]
        } else if ($i ~ /^runtime_health=/) {
          split($i, parts, "=")
          line_runtime_health = parts[2]
        } else if ($i ~ /^runtime_bottleneck=/) {
          split($i, parts, "=")
          line_runtime_bottleneck = parts[2]
        } else if ($i ~ /^runtime_tick_p95=/) {
          split($i, parts, "=")
          line_runtime_tick = parts[2] + 0
        } else if ($i ~ /^runtime_decision_p95=/) {
          split($i, parts, "=")
          line_runtime_decision = parts[2] + 0
        } else if ($i ~ /^runtime_action_p95=/) {
          split($i, parts, "=")
          line_runtime_action = parts[2] + 0
        } else if ($i ~ /^runtime_callback_p95=/) {
          split($i, parts, "=")
          line_runtime_callback = parts[2] + 0
        } else if ($i ~ /^runtime_llm_api_p95=/) {
          split($i, parts, "=")
          line_runtime_llm_api = parts[2] + 0
        } else if ($i ~ /^label_capacity_hit=/) {
          split($i, parts, "=")
          line_label_capacity = parts[2]
        } else if ($i ~ /^overlay_capacity_hit=/) {
          split($i, parts, "=")
          line_overlay_capacity = parts[2]
        } else if ($i ~ /^event_backlog_hit=/) {
          split($i, parts, "=")
          line_event_backlog = parts[2]
        }
      }
      if (line_avg != "") {
        avg_last = line_avg
      }
      if (line_p95 != "" && line_p95 > p95_peak) {
        p95_peak = line_p95
      }
      if (line_over != "" && line_over > over_peak) {
        over_peak = line_over
      }
      if (line_auto == "true") {
        auto_seen = 1
      }
      if (line_hotspot != "") {
        hotspot_last = line_hotspot
        if (line_hotspot != "none") {
          hotspot_hits[line_hotspot] += 1
        }
      }
      if (line_runtime_health != "") {
        runtime_health_last = line_runtime_health
      }
      if (line_runtime_bottleneck != "") {
        runtime_bottleneck_last = line_runtime_bottleneck
      }
      if (line_runtime_tick != "" && line_runtime_tick > runtime_tick_peak) {
        runtime_tick_peak = line_runtime_tick
      }
      if (line_runtime_decision != "" && line_runtime_decision > runtime_decision_peak) {
        runtime_decision_peak = line_runtime_decision
      }
      if (line_runtime_action != "" && line_runtime_action > runtime_action_peak) {
        runtime_action_peak = line_runtime_action
      }
      if (line_runtime_callback != "" && line_runtime_callback > runtime_callback_peak) {
        runtime_callback_peak = line_runtime_callback
      }
      if (line_runtime_llm_api != "" && line_runtime_llm_api > runtime_llm_api_peak) {
        runtime_llm_api_peak = line_runtime_llm_api
      }
      if (line_label_capacity == "true") {
        label_capacity_seen = 1
      }
      if (line_overlay_capacity == "true") {
        overlay_capacity_seen = 1
      }
      if (line_event_backlog == "true") {
        event_backlog_seen = 1
      }
      samples++
    }
    END {
      hotspot_primary = "none"
      hotspot_primary_hits = 0
      for (name in hotspot_hits) {
        if (hotspot_hits[name] > hotspot_primary_hits) {
          hotspot_primary = name
          hotspot_primary_hits = hotspot_hits[name]
        }
      }
      if (runtime_health_last == "") {
        runtime_health_last = "unknown"
      }
      if (runtime_bottleneck_last == "") {
        runtime_bottleneck_last = "none"
      }
      printf "%.2f\t%.2f\t%.2f\t%d\t%s\t%s\t%s\t%s\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%s\t%s\t%s\n",
        avg_last + 0,
        p95_peak + 0,
        over_peak + 0,
        samples + 0,
        (auto_seen ? "true" : "false"),
        hotspot_primary,
        runtime_health_last,
        runtime_bottleneck_last,
        runtime_tick_peak + 0,
        runtime_decision_peak + 0,
        runtime_action_peak + 0,
        runtime_callback_peak + 0,
        runtime_llm_api_peak + 0,
        (label_capacity_seen ? "true" : "false"),
        (overlay_capacity_seen ? "true" : "false"),
        (event_backlog_seen ? "true" : "false")
    }
  ' "$log_file"
}

duration_secs=45
tick_ms=120
base_port=5420
out_root=".tmp/viewer_owr4_stress"
event_window_size=50000
scenarios_csv="triad_region_bootstrap,llm_bootstrap"
profile="web_desktop"
fps_target=""
fps_min=""
perf_budget_ms=""
max_over_budget_pct="10"
baseline_csv=""
max_regression_pct="10"
enforce_gate=0
prewarm=1

while [[ $# -gt 0 ]]; do
  case "$1" in
    --duration-secs)
      duration_secs=${2:-}
      shift 2
      ;;
    --tick-ms)
      tick_ms=${2:-}
      shift 2
      ;;
    --base-port)
      base_port=${2:-}
      shift 2
      ;;
    --out-dir)
      out_root=${2:-}
      shift 2
      ;;
    --event-window-size)
      event_window_size=${2:-}
      shift 2
      ;;
    --scenarios)
      scenarios_csv=${2:-}
      shift 2
      ;;
    --profile)
      profile=${2:-}
      shift 2
      ;;
    --fps-target)
      fps_target=${2:-}
      shift 2
      ;;
    --fps-min)
      fps_min=${2:-}
      shift 2
      ;;
    --perf-budget-ms)
      perf_budget_ms=${2:-}
      shift 2
      ;;
    --max-over-budget-pct)
      max_over_budget_pct=${2:-}
      shift 2
      ;;
    --baseline-csv)
      baseline_csv=${2:-}
      shift 2
      ;;
    --max-regression-pct)
      max_regression_pct=${2:-}
      shift 2
      ;;
    --enforce-gate)
      enforce_gate=1
      shift
      ;;
    --no-prewarm)
      prewarm=0
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "unknown option: $1" >&2
      usage
      exit 1
      ;;
  esac
done

for value_name in duration_secs tick_ms base_port event_window_size; do
  value=${!value_name}
  if [[ ! "$value" =~ ^[0-9]+$ ]] || [[ "$value" -le 0 ]]; then
    echo "invalid $value_name: $value" >&2
    exit 1
  fi
done

for float_name in fps_target fps_min perf_budget_ms max_over_budget_pct max_regression_pct; do
  value=${!float_name}
  if [[ -n "$value" ]] && [[ ! "$value" =~ ^[0-9]+([.][0-9]+)?$ ]]; then
    echo "invalid $float_name: $value" >&2
    exit 1
  fi
done

if [[ -z "$scenarios_csv" ]]; then
  echo "scenarios list cannot be empty" >&2
  exit 1
fi

case "$profile" in
  web_desktop)
    profile_fps_target=60
    profile_fps_min=30
    ;;
  high_density)
    profile_fps_target=60
    profile_fps_min=50
    ;;
  stress)
    profile_fps_target=30
    profile_fps_min=25
    ;;
  *)
    echo "invalid profile: $profile" >&2
    exit 1
    ;;
esac

if [[ -z "$fps_target" ]]; then
  fps_target=$profile_fps_target
fi
if [[ -z "$fps_min" ]]; then
  fps_min=$profile_fps_min
fi
if [[ -z "$perf_budget_ms" ]]; then
  perf_budget_ms=$(awk -v fps="$fps_min" 'BEGIN { if (fps > 0) printf "%.2f", 1000.0 / fps; else printf "0" }')
fi

if float_lt "$fps_target" "1" || float_lt "$fps_min" "1" || float_lt "$perf_budget_ms" "1"; then
  echo "fps/perf budget values must be positive" >&2
  exit 1
fi

if [[ -n "$baseline_csv" ]] && [[ ! -f "$baseline_csv" ]]; then
  echo "baseline csv not found: $baseline_csv" >&2
  exit 1
fi

baseline_enabled=0
baseline_warning=""
declare -A baseline_event_rate
declare -A baseline_frame_ms_p95_peak
if [[ -n "$baseline_csv" ]]; then
  if head -n 1 "$baseline_csv" | grep -q "frame_ms_p95_peak"; then
    baseline_enabled=1
    while IFS=',' read -r b_scenario _b_mode _b_profile _b_duration _b_tick _b_events b_event_rate _b_status _b_fps_target _b_fps_min _b_budget _b_frame_avg b_frame_p95 _b_fps_avg _b_fps_p95 _b_over _b_max_over _b_auto _b_samples _b_metric_gate _b_baseline_gate _b_scenario_gate _b_notes _b_server _b_viewer; do
      if [[ "$b_scenario" == "scenario" ]] || [[ -z "$b_scenario" ]]; then
        continue
      fi
      baseline_event_rate["$b_scenario"]="$b_event_rate"
      baseline_frame_ms_p95_peak["$b_scenario"]="$b_frame_p95"
    done < "$baseline_csv"
  else
    baseline_warning="baseline csv missing required columns (frame_ms_p95_peak); baseline compare skipped"
  fi
fi

if [[ "$prewarm" == "1" ]]; then
  run env -u RUSTC_WRAPPER cargo build -p agent_world --bin world_viewer_live
  run env -u RUSTC_WRAPPER cargo build -p agent_world_viewer
fi

timestamp=$(date +%Y%m%d-%H%M%S)
run_dir="$out_root/$timestamp"
run mkdir -p "$run_dir"

summary_csv="$run_dir/metrics.csv"
summary_md="$run_dir/summary.md"
summary_json="$run_dir/summary.json"

echo "scenario,mode,profile,duration_secs,tick_ms,final_events,event_rate,status,fps_target,fps_min,frame_ms_budget,frame_ms_avg_last,frame_ms_p95_peak,fps_avg_last,fps_p95_peak,over_budget_pct_peak,max_over_budget_pct,auto_degrade_seen,perf_samples,metric_gate,baseline_gate,scenario_gate,gate_notes,server_log,viewer_log,hotspot_primary,runtime_health_last,runtime_bottleneck_last,runtime_tick_p95_peak,runtime_decision_p95_peak,runtime_action_p95_peak,runtime_callback_p95_peak,runtime_llm_api_p95_peak,runtime_peak_stage,runtime_peak_p95_ms,label_capacity_seen,overlay_capacity_seen,event_backlog_seen" > "$summary_csv"

server_pid=""
viewer_pid=""

overall_status="pass"

cleanup() {
  for pid in "$viewer_pid" "$server_pid"; do
    if [[ -n "$pid" ]] && kill -0 "$pid" >/dev/null 2>&1; then
      kill "$pid" >/dev/null 2>&1 || true
      wait "$pid" >/dev/null 2>&1 || true
    fi
  done
  viewer_pid=""
  server_pid=""
}
trap cleanup EXIT

IFS=',' read -r -a scenarios <<< "$scenarios_csv"

index=0
for scenario_raw in "${scenarios[@]}"; do
  scenario=$(echo "$scenario_raw" | xargs)
  if [[ -z "$scenario" ]]; then
    continue
  fi

  port=$((base_port + index))
  addr="127.0.0.1:${port}"
  scenario_dir="$run_dir/$scenario"
  run mkdir -p "$scenario_dir"
  server_log="$scenario_dir/live_server.log"
  viewer_log="$scenario_dir/viewer.log"

  mode="script"
  server_cmd=(env -u RUSTC_WRAPPER cargo run -p agent_world --bin world_viewer_live -- "$scenario" --bind "$addr" --tick-ms "$tick_ms")
  if [[ "$scenario" == "llm_bootstrap" ]]; then
    if [[ -n "${OPENAI_API_KEY:-}" ]]; then
      mode="llm"
      server_cmd+=(--llm)
    else
      mode="script_fallback(no_openai_key)"
    fi
  fi

  echo "== scenario: $scenario ($mode) =="
  echo "+ ${server_cmd[*]} > $server_log"
  "${server_cmd[@]}" >"$server_log" 2>&1 &
  server_pid=$!
  sleep 2

  viewer_cmd=(env -u RUSTC_WRAPPER cargo run -p agent_world_viewer -- "$addr")
  echo "+ AGENT_WORLD_VIEWER_HEADLESS=1 AGENT_WORLD_VIEWER_FORCE_ONLINE=1 AGENT_WORLD_VIEWER_EVENT_WINDOW_SIZE=$event_window_size AGENT_WORLD_VIEWER_PERF_PROBE=1 AGENT_WORLD_VIEWER_PERF_PROBE_INTERVAL_SECS=1 AGENT_WORLD_VIEWER_PERF_BUDGET_MS=$perf_budget_ms ${viewer_cmd[*]} > $viewer_log"
  AGENT_WORLD_VIEWER_HEADLESS=1 \
  AGENT_WORLD_VIEWER_FORCE_ONLINE=1 \
  AGENT_WORLD_VIEWER_EVENT_WINDOW_SIZE="$event_window_size" \
  AGENT_WORLD_VIEWER_PERF_PROBE=1 \
  AGENT_WORLD_VIEWER_PERF_PROBE_INTERVAL_SECS=1 \
  AGENT_WORLD_VIEWER_PERF_BUDGET_MS="$perf_budget_ms" \
  "${viewer_cmd[@]}" >"$viewer_log" 2>&1 &
  viewer_pid=$!

  sleep "$duration_secs"
  cleanup

  final_events=$(awk '/viewer events:/ {value=$3} END {if (value=="") value=0; print value}' "$viewer_log")
  status=$(awk -F': ' '/viewer status:/ {value=$2} END {if (value=="") value="unknown"; print value}' "$viewer_log")
  event_rate=$(awk -v events="$final_events" -v secs="$duration_secs" 'BEGIN { printf "%.2f", (secs > 0 ? events / secs : 0) }')

  IFS=$'\t' read -r frame_ms_avg_last frame_ms_p95_peak over_budget_pct_peak perf_samples auto_degrade_seen hotspot_primary runtime_health_last runtime_bottleneck_last runtime_tick_p95_peak runtime_decision_p95_peak runtime_action_p95_peak runtime_callback_p95_peak runtime_llm_api_p95_peak label_capacity_seen overlay_capacity_seen event_backlog_seen < <(parse_perf_metrics "$viewer_log")

  fps_avg_last=$(awk -v ms="$frame_ms_avg_last" 'BEGIN { if (ms > 0) printf "%.2f", 1000.0 / ms; else printf "0.00" }')
  fps_p95_peak=$(awk -v ms="$frame_ms_p95_peak" 'BEGIN { if (ms > 0) printf "%.2f", 1000.0 / ms; else printf "0.00" }')

  metric_gate="pass"
  baseline_gate="n/a"
  scenario_gate="pass"
  notes=()

  if [[ "$status" != "connected" ]]; then
    metric_gate="fail"
    notes+=("status_not_connected:$status")
  fi
  if [[ "$perf_samples" -eq 0 ]]; then
    metric_gate="fail"
    notes+=("perf_samples_zero")
  fi
  if float_lt "$fps_avg_last" "$fps_min"; then
    metric_gate="fail"
    notes+=("fps_avg_below_min:${fps_avg_last}<${fps_min}")
  fi
  if float_lt "$fps_p95_peak" "$fps_min"; then
    metric_gate="fail"
    notes+=("fps_p95_below_min:${fps_p95_peak}<${fps_min}")
  fi
  if float_gt "$over_budget_pct_peak" "$max_over_budget_pct"; then
    metric_gate="fail"
    notes+=("over_budget_pct:${over_budget_pct_peak}>${max_over_budget_pct}")
  fi
  if float_lt "$fps_avg_last" "$fps_target"; then
    notes+=("fps_avg_below_target:${fps_avg_last}<${fps_target}")
  fi
  if [[ "$auto_degrade_seen" == "true" ]]; then
    notes+=("auto_degrade_triggered")
  fi
  if [[ "$hotspot_primary" != "none" ]]; then
    notes+=("hotspot:$hotspot_primary")
  fi
  if [[ "$runtime_health_last" != "unknown" || "$runtime_bottleneck_last" != "none" ]]; then
    notes+=("runtime:${runtime_health_last}/${runtime_bottleneck_last}")
  fi
  if [[ "$label_capacity_seen" == "true" ]]; then
    notes+=("label_capacity_hit")
  fi
  if [[ "$overlay_capacity_seen" == "true" ]]; then
    notes+=("overlay_capacity_hit")
  fi
  if [[ "$event_backlog_seen" == "true" ]]; then
    notes+=("event_backlog_hit")
  fi

  runtime_peak_stage="none"
  runtime_peak_p95_ms="0.00"
  for stage in tick decision action callback llm_api; do
    case "$stage" in
      tick) candidate="$runtime_tick_p95_peak" ;;
      decision) candidate="$runtime_decision_p95_peak" ;;
      action) candidate="$runtime_action_p95_peak" ;;
      callback) candidate="$runtime_callback_p95_peak" ;;
      llm_api) candidate="$runtime_llm_api_p95_peak" ;;
      *) candidate="0.00" ;;
    esac
    if float_gt "$candidate" "$runtime_peak_p95_ms"; then
      runtime_peak_stage="$stage"
      runtime_peak_p95_ms="$candidate"
    fi
  done
  if [[ "$runtime_peak_stage" != "none" ]]; then
    notes+=("runtime_peak:${runtime_peak_stage}=${runtime_peak_p95_ms}ms")
  fi

  if [[ "$baseline_enabled" -eq 1 ]]; then
    baseline_event="${baseline_event_rate[$scenario]:-}"
    baseline_p95="${baseline_frame_ms_p95_peak[$scenario]:-}"
    if [[ -z "$baseline_event" || -z "$baseline_p95" ]]; then
      baseline_gate="missing"
      notes+=("baseline_missing:$scenario")
    else
      baseline_gate="pass"
      min_event_rate=$(awk -v value="$baseline_event" -v pct="$max_regression_pct" 'BEGIN { printf "%.4f", value * (1.0 - pct / 100.0) }')
      max_frame_p95=$(awk -v value="$baseline_p95" -v pct="$max_regression_pct" 'BEGIN { printf "%.4f", value * (1.0 + pct / 100.0) }')
      if float_lt "$event_rate" "$min_event_rate"; then
        baseline_gate="fail"
        notes+=("event_rate_regression:${event_rate}<${min_event_rate}")
      fi
      if float_gt "$frame_ms_p95_peak" "$max_frame_p95"; then
        baseline_gate="fail"
        notes+=("frame_p95_regression:${frame_ms_p95_peak}>${max_frame_p95}")
      fi
    fi
  fi

  if [[ "$metric_gate" == "fail" || "$baseline_gate" == "fail" ]]; then
    scenario_gate="fail"
    overall_status="fail"
  fi

  gate_notes=$(join_notes "${notes[@]}")

  echo "$scenario,$mode,$profile,$duration_secs,$tick_ms,$final_events,$event_rate,$status,$fps_target,$fps_min,$perf_budget_ms,$frame_ms_avg_last,$frame_ms_p95_peak,$fps_avg_last,$fps_p95_peak,$over_budget_pct_peak,$max_over_budget_pct,$auto_degrade_seen,$perf_samples,$metric_gate,$baseline_gate,$scenario_gate,$gate_notes,$server_log,$viewer_log,$hotspot_primary,$runtime_health_last,$runtime_bottleneck_last,$runtime_tick_p95_peak,$runtime_decision_p95_peak,$runtime_action_p95_peak,$runtime_callback_p95_peak,$runtime_llm_api_p95_peak,$runtime_peak_stage,$runtime_peak_p95_ms,$label_capacity_seen,$overlay_capacity_seen,$event_backlog_seen" >> "$summary_csv"
  index=$((index + 1))
done

python3 - "$summary_csv" "$summary_json" "$overall_status" "$profile" "$fps_target" "$fps_min" "$perf_budget_ms" "$max_over_budget_pct" "$max_regression_pct" "$baseline_csv" <<'PY'
import csv
import json
import pathlib
import sys

(
    csv_path,
    json_path,
    overall_status,
    profile,
    fps_target,
    fps_min,
    perf_budget_ms,
    max_over_budget_pct,
    max_regression_pct,
    baseline_csv,
) = sys.argv[1:]

rows = []
with open(csv_path, "r", encoding="utf-8") as fh:
    reader = csv.DictReader(fh)
    for row in reader:
        rows.append(row)

payload = {
    "overall_status": overall_status,
    "config": {
        "profile": profile,
        "fps_target": float(fps_target),
        "fps_min": float(fps_min),
        "perf_budget_ms": float(perf_budget_ms),
        "max_over_budget_pct": float(max_over_budget_pct),
        "max_regression_pct": float(max_regression_pct),
        "baseline_csv": baseline_csv,
    },
    "scenarios": rows,
}

pathlib.Path(json_path).write_text(
    json.dumps(payload, ensure_ascii=False, indent=2) + "\n",
    encoding="utf-8",
)
PY

{
  echo "# OWR4 压测结果摘要"
  echo
  echo "- 运行目录：\`$run_dir\`"
  echo "- 运行时长（每场景）：\`$duration_secs\` 秒"
  echo "- Tick 间隔：\`$tick_ms\` ms"
  echo "- Profile：\`$profile\`"
  echo "- Gate 阈值：\`fps_target=$fps_target\`，\`fps_min=$fps_min\`，\`perf_budget_ms=$perf_budget_ms\`，\`max_over_budget_pct=$max_over_budget_pct\`"
  if [[ "$baseline_enabled" -eq 1 ]]; then
    echo "- Baseline：\`$baseline_csv\`（max_regression_pct=\`$max_regression_pct\`）"
  elif [[ -n "$baseline_csv" ]]; then
    echo "- Baseline：\`$baseline_csv\`（已跳过：$baseline_warning）"
  else
    echo "- Baseline：未启用"
  fi
  echo "- 参考模板：\`doc/world-simulator/viewer-open-world-sandbox-readiness.stress-report.template.md\`"
  echo "- overall_status：\`$overall_status\`"
  echo
  echo "| Scenario | Mode | Events/s | FPS(avg/p95) | Frame(avg/p95 ms) | OverBudget% | Hotspot | Runtime Peak p95 | Status | Metric Gate | Baseline Gate | Scenario Gate | Notes |"
  echo "|---|---|---:|---:|---:|---:|---|---:|---|---|---|---|---|"
  tail -n +2 "$summary_csv" | while IFS=',' read -r scenario mode _profile _dur _tick _events event_rate status _fps_target _fps_min _budget frame_avg frame_p95 fps_avg fps_p95 over_pct _max_over _auto _samples metric_gate baseline_gate scenario_gate gate_notes _server _viewer hotspot runtime_health runtime_bottleneck _rt_tick _rt_decision _rt_action _rt_callback _rt_llm runtime_peak_stage runtime_peak_p95_ms _label_seen _overlay_seen _event_seen; do
    runtime_peak_cell="$runtime_peak_stage:$runtime_peak_p95_ms"
    hotspot_cell="$hotspot"
    if [[ "$runtime_health" != "unknown" || "$runtime_bottleneck" != "none" ]]; then
      hotspot_cell="${hotspot} (${runtime_health}/${runtime_bottleneck})"
    fi
    echo "| $scenario | $mode | $event_rate | $fps_avg/$fps_p95 | $frame_avg/$frame_p95 | $over_pct | $hotspot_cell | $runtime_peak_cell | $status | $metric_gate | $baseline_gate | $scenario_gate | $gate_notes |"
  done
} > "$summary_md"

echo "stress run completed:"
echo "  csv:  $summary_csv"
echo "  md:   $summary_md"
echo "  json: $summary_json"

if [[ "$enforce_gate" -eq 1 && "$overall_status" != "pass" ]]; then
  echo "gate failed: overall_status=$overall_status" >&2
  exit 2
fi
