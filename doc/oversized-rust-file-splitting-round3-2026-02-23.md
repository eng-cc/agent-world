# Rust 超限文件拆分（第三轮，2026-02-23）

## 目标
- 将仓库内全部超过约束（单个 Rust 文件 >1200 行）的文件在本轮全部收口至阈值内。
- 维持行为与对外接口不变，优先采用低风险“结构拆分”而非语义重写。

## 范围
- In scope
  - 覆盖当前扫描出的全部 22 个超限 Rust 文件（含测试文件、bin 文件、生产模块）。
  - 采用可回溯、可批量执行的拆分策略（`include!` 分段文件 / 子模块拆分）。
  - 统一执行编译与定向回归，复核“零超限”结果。
- Out of scope
  - 协议/业务语义调整。
  - 非超限文件的风格性重排。
  - `third_party/` 下代码修改。

## 接口 / 数据
- 对外 API 与协议字段不变。
- 仅调整源文件组织方式：
  - 将超长文件切分为多个同目录分段文件（例如 `*_parts/part*.rs`）并通过 `include!` 拼接；
  - 或按模块职责拆分为子模块文件并通过 `mod` 接线。
- 不引入序列化兼容性变化。

## 里程碑
- M1：完成 round3 文档与任务拆解（T0）。
- M2：批量完成 22 个超限 Rust 文件拆分并通过 `cargo check`（T1）。
- M3：完成定向回归与全量超限复核（T2）。
- M4：回写项目文档/devlog 并收口（T3）。

## 风险
- 批量拆分风险：切分点选择错误导致语法/可见性问题。
- include 路径风险：相对路径错误导致编译失败。
- 回归覆盖风险：重构不改语义但可能触发边界编译/测试问题，需以定向测试兜底。
