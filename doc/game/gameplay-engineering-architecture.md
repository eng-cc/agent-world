# 游戏性模块化架构设计规范 v0.2  
## —— 基于 WASM 的可插拔玩法层实现方案

> 目标：  
> 在既有“世界模拟内核 + Agent OS + 区块链共识层”之上，  
> 构建一个**完全由 WASM 承载的游戏性层（Gameplay Layer）**，  
> 使不同玩法可以作为模块组合加载，而不污染底层物理规则。

---

# 1. 设计目标

1. 所有“好玩”的逻辑不写入底层模拟内核
2. 所有玩法规则可卸载 / 替换 / 组合
3. 不破坏资源守恒、时间单向、Agent 唯一性等世界不变量
4. 支持多套玩法并行存在
5. 支持未来社区提交玩法模块

## 1.1 范围

### In Scope
- 基于 WASM 的 Gameplay Layer 分层和边界约束。
- Gameplay Kernel API（只读、提案、事件机制）语义定义。
- 模块生命周期、分类、Game Mode 组合加载机制。
- 安全隔离、Gas 计量、不变量保护与多玩法并行机制。

### Out of Scope
- 世界模拟内核/区块链共识层内部实现细节。
- 具体模块代码、链上合约代码与部署流程脚本。
- 数值平衡参数与玩法调优实验流程。

## 1.2 接口/数据

- 关键接口：`read`（只读视图）、`proposal`（状态变更提案）、`emit_event/subscribe`（事件总线）。
- 关键模块数据：模块元信息（模块类型、权限边界、资源上限）、订阅事件类型、提案载荷。
- 关键运行时数据：Gas 预算、执行计量结果、提案验证结果、治理决议状态。

## 1.3 里程碑

- E0：冻结分层架构与边界约束。
- E1：完成 Gameplay Kernel API 与生命周期接口落地。
- E2：完成 War/Governance/Crisis/Economic/Meta 五类模块最小实现。
- E3：完成 Game Mode 组合加载与治理替换闭环。
- E4：完成安全/性能基线校验与并行玩法回归。

## 1.4 风险

- 模块边界定义不清，可能导致内核与玩法层职责混叠。
- Gas 或沙箱约束过严会抑制玩法表达，过松会引发性能与安全风险。
- 多玩法并行可能导致规则冲突，需要治理与冲突检测机制兜底。
- 社区模块生态引入后，审核与兼容性成本持续增长。

---

# 2. 总体分层结构

```

┌───────────────────────────────┐
│        客户端 UI 层             │
├───────────────────────────────┤
│   Gameplay WASM 模块层         │ ← 可插拔
├───────────────────────────────┤
│     Agent OS 决策执行层         │
├───────────────────────────────┤
│     世界模拟内核（物理/资源）     │
├───────────────────────────────┤
│     区块链共识与状态层           │
└───────────────────────────────┘

```

### 分层职责

| 层级 | 职责 |
|------|------|
| 世界内核 | 时间推进、资源守恒、空间计算 |
| Agent OS | 执行目标、调度推理 |
| Gameplay 层 | 战争、政治、任务、成就、事件等 |
| 客户端 | 展示与交互 |

---

# 3. Gameplay 模块的核心模型

## 3.1 本质定义

Gameplay 模块是：

> 一个“受限的状态观察 + 规则计算 + 状态变更提案”的 WASM 沙箱。

它不能直接修改世界状态，只能：

1. 读取授权状态
2. 计算规则
3. 提交变更提案
4. 发出信号事件

---

# 4. Gameplay Kernel API 规范

所有模块只能通过统一 API 与世界交互。

---

## 4.1 读取接口（只读）

特点：

* 只读
* 不消耗状态
* 可能消耗 gas

---

## 4.2 状态提案接口（写入申请）

注意：

* 只是“提案”
* 内核负责验证合法性
* 不符合守恒规则则拒绝

---

## 4.3 事件机制（Event Bus）

模块可：

```text
emit_event(type, data)
subscribe(event_type)
```

事件系统用于：

* 战争触发
* 投票开始
* 危机生成
* 组织成立

---

# 5. 模块生命周期

每个 Gameplay WASM 模块至少具备以下语义的生命周期(实际命名由工程实现决定)：

```text
on_init()
on_tick(world_state_view)
on_event(event)
on_shutdown()
```

说明：
* on_tick 在每个逻辑 Tick 调用
* on_event 响应订阅事件
* gas 消耗限制执行时间

---

# 6. Gameplay 模块分类(一种假设)

---

## 6.1 战争模块（War Module）

职责：

* 攻击判定
* 伤害计算
* 区域争夺逻辑

流程：

1. 监听攻击事件
2. 校验双方资源
3. 计算结果
4. 提交 damage 提案
5. 发出战报事件

必须：

* 校验能量来源
* 校验攻击距离
* 校验模块合法性

---

## 6.2 政治治理模块（Governance Module）

职责：

* 投票机制
* 提案生命周期
* 权重计算

流程：

1. 创建提案
2. 设定投票周期
3. 汇总权重
4. 提交协议修改提案

---

## 6.3 事件与危机模块（Crisis Module）

职责：

* 周期性危机
* 随机扰动
* 环境变化

示例：

* 小行星风暴
* 能源衰减期
* 算力波动

---

## 6.4 经济覆盖模块（Economic Overlay）

职责：

* 税率计算
* 奖励分配
* 市场撮合

不得：

* 直接创造资源
* 违反守恒原则

---

## 6.5 成就与任务模块（Meta Progression）

职责：

* 阶段目标
* 成就判定
* 排名计算

不影响物理层，只影响展示与奖励。

---

# 7. Game Mode 容器机制

## 7.1 定义

Game Mode = 一组 WASM 模块组合。

示例：

### 工业模式

* 生产优化模块
* 自动化评分模块
* 效率排行榜模块

### 战争模式

* 区域控制模块
* 军事判定模块
* 情报系统模块

---

## 7.2 加载方式

Game Mode 在世界创建时声明：

模块注册需链上共识。

---

# 8. Gas 与资源消耗机制

所有 WASM 执行必须：

* 消耗 Gas
* Gas 由代币支付
* 超出上限立即终止

目的：

* 防止无限循环
* 防止模块滥用计算

---

# 9. 安全与隔离

1. 模块运行在沙箱
2. 不可访问宿主内存
3. 不可绕过 API
4. 所有状态变更需内核验证

---

# 10. 多玩法并行机制

支持：

* 不同分区加载不同玩法
* Agent在不同分区受不同分区的游戏规则限制
* 分区是指游戏里的空间，目前只有默认空间
* 同一世界启用多个模块
* 通过治理提案替换玩法模块

---

# 11. 玩家自定义玩法扩展（未来方向）

流程：

1. 开发 WASM 模块
2. 提交链上注册
3. 通过投票审核
4. 成为官方 Game Mode 选项

这使系统成为：

> 一个文明玩法生态市场

---

# 12. 不变量保护机制

Gameplay 模块不得：

* 生成凭空资源
* 修改时间推进规则
* 复制 Agent
* 直接写世界状态

底层内核必须：

* 校验资源守恒
* 校验能量流
* 校验空间约束
* 校验攻击合法性

---

# 13. 性能与可扩展性

为避免全局性能瓶颈：

* 模块仅对订阅事件执行
* 支持区域级执行
* 支持并行执行
* 通过共识合并结果

---

# 14. 架构总结

底层世界 = 物理宇宙
Agent OS = 智能行为
Gameplay WASM = 文明规则层
区块链 = 可信状态机

所有“好玩”的东西必须：

> 可插拔
> 可替换
> 可升级
> 可治理

---

# 结语

通过将游戏性逻辑完全外置到 WASM 模块层：

* 你不会被玩法锁死
* 你可以同时运行多种文明模式
* 你可以让社区创造新规则
* 你可以让世界演化自己的“游戏类型”

这不只是一个游戏架构。

这是一个可加载不同文明规则的操作系统。

---

现在我们已经进入真正工程层设计阶段了。
